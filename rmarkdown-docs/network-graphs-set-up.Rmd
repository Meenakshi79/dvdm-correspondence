---
title: "Setting up Network Visualizations"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: cosmo
    highlight: textmate
---

* Need to go back through document
  * General proofreading. Be aware of voice.
  * Consistency on italics, bold, and code with packages, dataframes, etc.
  * Links to packages etc.
  * Further reading

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
This document shows how to take raw data from the letters sent to Daniel van der Meulen and create dataframes that can be used for network visualization by packages such as **igraph** and **network**. This will also cover making htmlwidget interactive networks with **vizNetwork** and **Networkd3**.

The first step is to load the data and the [tidyverse](http://www.tidyverse.org) package to be able to manipulate the data
```{r load data, message = FALSE}
library(tidyverse)
letters <- read_csv("data/dvdm-correspondence-1591.csv")
```

## Create nodes and edges dataframes
The goal of this script is to get the data from the letters into two separate dataframes that can be read by the networking packages: nodes and links. This is all done with the **dplyr** package.

The first dataframe will consist of a list of the **nodes**, or vertices, or in this case the cities from which Daniel was sent letters or in which he received letters. It will also be necessary to have an `id` column so that each city has a unique identifyer. The `id` column should be the first column of the dataframe.

The second dataframe will be the **links** or edges between the nodes. Every source and destination will have an id that is taken from the nodes datafram. Like with the nodes, the *source_id* and *destination_id* should be the first two columns of the dataframe. We will label these `id` columns *from* and *to*, because that is the format expected for the **visNetwork** package. The dataframe will also have a weight column of the count of the letters sent along each route.

The first step is to prepare the data by grouping the routes together and creating a count of how many letters were sent along each route. The below function also gets rid of all routes where either the source or the destination is unknown. This is shown by the warning that is produced.

```{r per_route}
per_route <- letters %>%  
  group_by(source, destination) %>%
  summarise(count = n()) %>%
  remove_missing() %>%
  arrange(desc(count)) %>% 
  ungroup()
```

### Nodes dataframe
With this preliminary step done it is now possible to create the nodes dataframe. The goal is to get a list of all the distinct locations from either the source or destination of the letters and then to give each a unique id.

We can find the unique sources and destination with the `distinct()` function. We also want to rename the source and destination column names to the same name — here place — so that they can be joined together.

```{r source and destination}
sources <- per_route %>%
  distinct(source) %>%
  rename(place = source)

destinations <- per_route %>%
  distinct(destination) %>%
  rename(place = destination)
```

To create a single dataframe with a column with the unique places we need to use a [full join](http://r4ds.had.co.nz/relational-data.html#outer-join), because we want to include unique places from both the sources of the letters and the destinations.

```{r nodes join}
nodes <- full_join(sources, destinations)
```

This results in a dataframe with 1 variable and is the length of the number of unique places in the letters data. It is now possible to add an `id` column with numbers from 1 to the length of the nodes dataframe. Note that it is not possible to use the pipe (`%>%`) between this function and the previous one because the object nodes has to be created before it can be used in the `nrow()` function.

```{r id column}
nodes <- add_column(nodes, id = 1:nrow(nodes))
```

Finally, we need to make the small change to make sure that the `id` column is the leftmost column of the dataframe. It would be possible to just list the columns within the `select()` function, but using the `everything()` function makes it possible to keep attribute columns if they existed.

```{r arrange nodes columns}
nodes <- select(nodes, id, everything())
```

### Links dataframe
The links dataframe is a bit easier to create. All that needs to be done is to take the `per_route` dataframe created above and add `id` columns for both source and destination. As already noted, it is easiest to name thems `from` and `to` for use with the **visNetwork** package.

The links dataframe is created by performing two [left joins](http://r4ds.had.co.nz/relational-data.html#outer-join) between the `per_route` dataframe and the `nodes` dataframe, first by source and then by destination. A left join is necessary here, because we only want to match ids to the cities that were either source or destination. The `id` columns are renamed to *to* and *from* by the `rename()` function.

```{r joins for links}
links <- per_route %>% 
  left_join(nodes, by = c("source" = "place")) %>% 
  rename(from = id) %>% 
  left_join(nodes, by = c("destination" = "place")) %>% 
  rename(to = id)
```

We then perform the same action to the links dataframe that we did to nodes by bringing the `id` columns to the left of the dataframe.

```{r arrange links columns}
links <- select(links, from, to, everything())
```

The result of these steps is the creation of two fairly simple dataframes with `id` columns that make it possible to make network objects.

```{r inspect tibbles}
nodes
links
```

## igraph and network
The **igraph** and **network** packages use different nomenclature, but both can read the data that we have created. The two packages overlap to such an extent that it is good practice to only have one loaded at a time.

### igraph
Load the **igraph** package

```{r load igraph, message = FALSE}
library(igraph)
```

The **igraph** function `graph_from_data_frame()` is rather simple to use. The only difficulty is understanding the meaning of *d* and *vertices*. Here, *d* refers to the edges or links, while vertices are the nodes. We also note that the network is directed.

```{r igraph object}
routes_network <- graph_from_data_frame(d = links, vertices = nodes, directed = TRUE)
```

It is now possible to get a rudimentary, if not overly aesthetically pleasing, plot.

```{r igraph plot}
plot(routes_network)
```

### Network
Before creating a **network** object, it is good practice to remove the **igraph** package and the igraph object that was created above.

```{r load network, message = FALSE}
detach(package:igraph)
rm(routes_network)
library(network)
```

Creating a network object is similar to that of igraph in that it is mainly a matter of placing our nodes and links dataframes in the right place and choosing a couple of options.

The function to create a network object is `network`. The first argument is, from the documentation, "a matrix giving the network structure in adjacency, incidence, or edgelist form." We do not have matrices, but we do have dataframes in the form of an edgelist, which is our links dataframe. Next is  a list of vertex attributes, which corresponds to the nodes dataframe. We then specify that our `matrix.type` is "edgelist". We can decide if we will allow loops or edges that link a node to itself. Our data does not have multiplex edges. Finally, we set `ignore.eval` to `FALSE` so that our network can be weighted and take into account the number of letters along each route.
```{r network object}
routes_network <- network(links, vertex.attr = nodes, matrix.type = "edgelist", 
                                  loops = TRUE, multiple = FALSE, ignore.eval = FALSE)
```

We can now get a similarly rudimentary graph as above.

```{r}
plot(routes_network)
```

Clean up our environment by removing the **network** package.

```{r remove network package}
detach(package:network)
rm(routes_network)
```

## Interactive network graphs
It is possible with [htmlwidgets](http://www.htmlwidgets.org) to use R to create interactive JavaScript visualizations that users can interact with. Here, I will show two popular options for network graphs with **visNetwork** and **Networkd3**

```{r interactive packages}
library(visNetwork)
library(networkD3)
```


### visNetwork
Creating a visNetwork visualization is about as easy as it gets, because we already did all of the preparation work. All that needs to be done is to list the nodes dataframe and the edges or links dataframe, and the result is an interactive network that has pleasant, if a bit plain, defaults.

```{r visNetwork}
visNetwork(nodes, links)
```

### Networkd3
A little more work is necessary to prepare our data for a Networkd3 vizualization, because the IDs have to be numeric and must begin with 0 instead of 1. This means that it is necessary to remake the nodes and links dataframes by tweeking the code a bit. The **Networkd3** package does not need the `id` columns to be leftmost in the dataframes, so those steps can be skipped.

We can create a new nodes dataframe directly from the sources and destinations dataframes already created above. The trick is to count the rows of the dataframe resulting from the full join and then create an `id` column from 0 to `nrow()` minus 1. Let's name the new datafram **nodes_d3** to distinguish it from the previous nodes dataframe.

```{r nodes_d3 join, message = FALSE}
nodes_d3 <- full_join(sources, destinations)
places <- nrow(nodes_d3)
nodes_d3 <- add_column(nodes_d3, id = 0:(places -1))
```

Creating the links dataframe proceeds in the same manner as above. It is not necessary to name the `id` columns `from` and `to`, but it is a good default. It is also not necessary to reorder the columns.

```{r}
links_d3 <- per_route %>% 
  left_join(nodes_d3, by = c("source" = "place")) %>% 
  rename(from = id) %>% 
  left_join(nodes_d3, by = c("destination" = "place")) %>% 
  rename(to = id)
```

It is now possible to plot a force-directed network graph.

```{r force network plot, message = FALSE}
forceNetwork(Links = links_d3, Nodes = nodes_d3, Source = "from", Target = "to", 
             Value = "count", NodeID = "place", Group = "id", zoom = TRUE)
```

The **networkd3** package also enables Sankey networks.

```{r sankey network, message = FALSE}
sankeyNetwork(Links = links_d3, Nodes = nodes_d3, Source = "from", Target = "to", 
              Value = "count", NodeID = "place", fontSize = 16, unit = "letter(s)")
```


## Further reading